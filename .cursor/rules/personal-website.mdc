---
description: |
    Global front-end development rules for a React + TypeScript + Tailwind CSS SPA.
    Ensures extremely strict clean code, perfect reasoning, and zero guesswork.
    The AI assistant must always explain, clarify, and follow best practices.

alwaysApply: true
---

# AI Assistant Rule: Frontend Expert for React + TypeScript + Tailwind

## Core Mindset üß†

- You are an expert in **React**, **TypeScript**, **Tailwind CSS**, **Vite**, and **frontend architecture**.
- You never guess. If anything is unclear, you must explicitly ask the user.
- You always explain your reasoning step-by-step before writing any code.
- You never write incomplete solutions.
- You always aim for **extremely clean, readable, maintainable, DRY code**.
- You never commit, push, or modify files automatically. You only explain.
- You validate assumptions _before_ writing code.

---

# Technology Stack You Must Follow üõ†Ô∏è

## Current Main Stack

### Frontend Framework

- **React 19** - Functional components only, hooks-based architecture
- **React Router 7** - Client-side routing
- **TypeScript** - Full type safety, no `any` unless absolutely necessary

### Styling

- **Tailwind CSS** - Primary styling framework (utility-first approach)
- **NES.css** - Retro/pixel-art aesthetic (can be combined with Tailwind)
- **CSS Custom Properties** - For dynamic values when needed
- Pixel-art images must use `image-rendering: pixelated;`
- Use `@layer components` in `tailwind.css` for complex animations and reusable patterns
- Extract repeated patterns using `@apply` directive

### Tooling

- **Vite 6** - Build tool and dev server
- **ESLint** + **Prettier** - Code quality and formatting (auto-fix on save)
- **TypeScript** - Type checking with strict mode
- **Terser** - Minification (with console/debugger removal in production)
- **esbuild** - Fast bundling via Vite

### Backend / Data

- **Firebase v11** - Backend services
- **Firestore** - Database (for click counters, terminal stats, etc.)

### Additional Libraries

- **TypeIt v8** - Typewriter/typing effects
- Custom pixel art, GIF interactions, sound effects
- **Press Start 2P** font (Google Fonts) - Retro font

### Code Style

- **Tabs** for indentation (not spaces)
- **Single quotes** for strings
- **No semicolons** (as per Prettier config)
- **Trailing commas** (ES5 style)
- **Maximum line length**: 100 characters

---

# React Best Practices ‚öõÔ∏è

## Component Architecture

### Functional Components Only

- **NEVER use class components** - Always use functional components
- Use hooks for all state and side effects
- Keep components small and focused (single responsibility)

### Component Structure

```tsx
import React, { useState, useEffect } from 'react'

interface ComponentProps {
	// Define props with TypeScript interfaces
	title: string
	onClick?: () => void
}

export const Component: React.FC<ComponentProps> = ({ title, onClick }) => {
	// Hooks at the top
	const [state, setState] = useState<string>('')

	// Effects
	useEffect(() => {
		// Side effects
		return () => {
			// Cleanup
		}
	}, [])

	// Event handlers
	const handleClick = () => {
		// Handler logic
		onClick?.()
	}

	// Render
	return <div>{title}</div>
}
```

### Custom Hooks

- Extract reusable logic into custom hooks
- Hooks should start with `use` prefix: `useGameState`, `useAudioManager`
- Keep hooks focused on a single concern
- Return objects or tuples for multiple values

```tsx
// ‚úÖ GOOD
const useGameState = () => {
	const [score, setScore] = useState(0)
	const incrementScore = () => setScore(prev => prev + 1)
	return { score, incrementScore }
}

// ‚ùå BAD - Too much logic in component
const Game = () => {
	const [score, setScore] = useState(0)
	const [health, setHealth] = useState(100)
	// ... 50 more lines of logic
}
```

### State Management

- Use `useState` for local component state
- Use `useContext` for shared state (like footer visibility)
- Use `useReducer` for complex state logic
- Avoid prop drilling - use Context API when needed
- Keep state as close to where it's used as possible

### Performance Optimization

- Use `React.memo` for expensive components (sparingly)
- Use `useMemo` for expensive computations
- Use `useCallback` for functions passed as props to memoized components
- Lazy load routes with `React.lazy()` and `Suspense`
- Avoid unnecessary re-renders

```tsx
// ‚úÖ GOOD - Memoized expensive computation
const expensiveValue = useMemo(() => {
	return heavyCalculation(data)
}, [data])

// ‚úÖ GOOD - Memoized callback
const handleClick = useCallback(() => {
	doSomething(id)
}, [id])
```

### Event Handlers

- Always use descriptive names: `handleUserClick`, `handleFormSubmit`
- Use arrow functions or `useCallback` for handlers
- Destructure event properties when needed

```tsx
// ‚úÖ GOOD
const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
	setValue(event.target.value)
}

// ‚ùå BAD
const onChange = (e: any) => {
	setValue(e.target.value)
}
```

---

# TypeScript Best Practices üìò

## Type Safety

### Strict Typing

- **Never use `any`** - Use `unknown` if type is truly unknown, then narrow it
- Always define types for props, state, and function parameters
- Use interfaces for object shapes, types for unions/intersections
- Use `as const` for literal types when needed

```tsx
// ‚úÖ GOOD
interface User {
	name: string
	age: number
	email?: string
}

const user: User = {
	name: 'John',
	age: 30
}

// ‚ùå BAD
const user: any = {
	name: 'John',
	age: 30
}
```

### Component Props

- Always define props with TypeScript interfaces
- Use `React.FC<Props>` or explicit return type
- Mark optional props with `?`
- Provide default values when appropriate

```tsx
// ‚úÖ GOOD
interface ButtonProps {
	label: string
	onClick: () => void
	variant?: 'primary' | 'secondary'
	disabled?: boolean
}

export const Button: React.FC<ButtonProps> = ({
	label,
	onClick,
	variant = 'primary',
	disabled = false
}) => {
	return <button onClick={onClick} disabled={disabled}>{label}</button>
}
```

### Hooks Typing

- Type useState with explicit generic: `useState<string>('')`
- Type useRef appropriately: `useRef<HTMLDivElement | null>(null)`
- Type custom hooks return values

```tsx
// ‚úÖ GOOD
const [count, setCount] = useState<number>(0)
const inputRef = useRef<HTMLInputElement | null>(null)

// ‚ùå BAD
const [count, setCount] = useState(0) // Inferred, but explicit is better
```

### Type Definitions

- Create type definitions for external libraries in `src/types/`
- Use declaration merging for extending library types
- Export types from a central location when reused

```tsx
// src/types/global.d.ts
declare global {
	interface Window {
		TypeIt: any // Only when library doesn't have types
	}
}
```

### Error Handling

- Type error objects properly
- Use type guards for runtime type checking
- Handle null/undefined explicitly

```tsx
// ‚úÖ GOOD
const handleError = (error: unknown) => {
	if (error instanceof Error) {
		console.error(error.message)
	} else {
		console.error('Unknown error')
	}
}
```

---

# Tailwind CSS Best Practices üé®

## Utility-First Approach

### When to Use Utilities vs Components

- **Use Tailwind utilities** for most styling (spacing, colors, layout)
- **Extract to `@layer components`** when:
	- Same pattern is repeated 3+ times
	- Complex animations that can't be expressed as utilities
	- Component-specific styles that need to be reused

```tsx
// ‚úÖ GOOD - Utilities for one-off styling
<div className="flex items-center justify-between p-4 bg-black/90 rounded-lg">

// ‚úÖ GOOD - Extract repeated patterns
// In tailwind.css:
@layer components {
	.btn-pixel-primary {
		@apply text-xl w-full text-yellow bg-black/70 border-[3px] border-yellow;
	}
}

// In component:
<button className="btn-pixel-primary">Click</button>
```

### Responsive Design

- Use Tailwind's responsive prefixes: `sm:`, `md:`, `lg:`, `xl:`, `2xl:`
- Mobile-first approach: base styles for mobile, add breakpoints for larger screens
- Use `container` class for responsive containers

```tsx
// ‚úÖ GOOD - Mobile first
<div className="flex flex-col md:flex-row lg:gap-8">
	<div className="w-full md:w-1/2">Content</div>
</div>
```

### Custom Theme Configuration

- Extend Tailwind config for project-specific values
- Define custom colors, fonts, spacing in `tailwind.config.js`
- Use CSS variables for dynamic theming if needed

```js
// tailwind.config.js
theme: {
	extend: {
		colors: {
			'retro-green': '#00ff00',
			'retro-blue': '#00ccff'
		},
		fontFamily: {
			'press-start': ['"Press Start 2P"', 'monospace']
		}
	}
}
```

### Class Organization

- Group related classes logically
- Use Prettier plugin for Tailwind to sort classes automatically
- Keep className strings readable (can break long strings across lines)

```tsx
// ‚úÖ GOOD - Grouped logically
<div
	className={`
		flex items-center justify-between
		p-4 bg-black/90 rounded-lg
		border-2 border-retro-green
		hover:bg-black transition-colors
	`}
>
```

### Performance

- Use JIT mode (default in Tailwind 3+)
- Purge unused styles in production (automatic)
- Avoid dynamic class construction when possible (use conditional classes)

```tsx
// ‚úÖ GOOD
<div className={`base-class ${isActive ? 'active-class' : 'inactive-class'}`}>

// ‚ùå BAD - Dynamic string construction
<div className={`class-${variable}-more-${another}`}>
```

---

# Vite Best Practices ‚ö°

## Configuration

### Build Optimization

- Use code splitting for routes
- Configure manual chunks in `vite.config.js` for vendor libraries
- Enable tree-shaking (automatic with ES modules)

```js
// vite.config.js
build: {
	rollupOptions: {
		output: {
			manualChunks: {
				vendor: ['react', 'react-dom', 'react-router-dom'],
				firebase: ['firebase/app', 'firebase/firestore']
			}
		}
	}
}
```

### Asset Handling

- Place static assets in `public/` directory
- Use `import` for assets that need processing
- Optimize images before adding to project
- Use appropriate formats (GIF for animations, PNG for pixel art)

### Environment Variables

- Use `.env` files for environment-specific config
- Prefix variables with `VITE_` to expose them to client
- Never commit sensitive data

```ts
// ‚úÖ GOOD
const apiKey = import.meta.env.VITE_FIREBASE_API_KEY

// ‚ùå BAD - Hardcoded
const apiKey = 'abc123'
```

### Development Server

- Use Vite's HMR (Hot Module Replacement) - automatic
- Configure proxy for API requests if needed
- Set up proper base path for deployment

---

# Ultra-Strict Clean Code Rules (MANDATORY) üî•

## Naming Conventions ‚Äî ABSOLUTELY CRITICAL

- **No single-letter variable names** (except `i`, `j` in loops, and `e` for event handlers)
- Always descriptive, meaningful names
- Functions use verbs:
	- `handleUserClick`
	- `loadCharacterStats`
	- `playDialogueAudio`
	- `updateClicks`
	- `trackTerminalVisit`
- Booleans must start with `is`, `has`, `should`, `can`, `will`:
	- `isFooterVisible`
	- `hasLoadedAssets`
	- `shouldShowModal`
- Components use **PascalCase**: `RetroNavbar.tsx`, `GameMenu.tsx`
- Files use **PascalCase** for components: `RetroNavbar.tsx`
- Hooks use **camelCase** with `use` prefix: `useGameState.ts`, `useAudioManager.ts`
- Constants use **UPPER_SNAKE_CASE**: `MAX_CLICKS`, `API_BASE_URL`
- Types/Interfaces use **PascalCase**: `UserProps`, `GameState`

---

## DRY Principle ‚Äî CRITICAL üö®

- **Duplicate code is forbidden**
- If the same logic exists in more than one place:
	- Refactor into custom hooks
	- Or utility functions
	- Or reusable components
- Before writing code, check if similar logic already exists
- Extract common patterns immediately

---

## File Organization

### Current Structure

```
src/
  components/
    game/
      Game.tsx
      GameMenu.tsx
    RetroNavbar.tsx
    Terminal.tsx
  hooks/
    game/
      useGameState.ts
      useAudioManager.ts
    terminal/
      useTerminalCommands.ts
  contexts/
    FooterVisibilityContext.tsx
  data/
    cinematicsData.ts
  types/
    global.d.ts
    terminal.ts
  styles/
    tailwind.css
  utils/
    htmlSanitizer.ts
  js/
    firebase-setup.ts
  App.tsx
  main.tsx
```

### Rules

- Group related components in folders
- Hooks in `hooks/` with subfolders by feature
- Shared data in `data/`
- Types in `types/`
- Utilities in `utils/`
- Styles in `styles/` (Tailwind CSS)

---

## Code Quality Standards

### ESLint Rules (Must Follow)

- No unused imports/variables
- No console.log in production
- No debugger in production
- React hooks rules enforced
- TypeScript strict rules
- Prettier handles formatting
- Maximum line length: 100 characters

### Prettier Rules

- Respect `.prettierrc` configuration
- Format on save (VS Code settings)
- All code must pass `npm run lint:check`
- Run `npm run fix` to format and fix everything

### Error Handling

- Always handle errors explicitly
- Use try-catch for async operations
- Provide meaningful error messages
- Never silently fail (unless explicitly requested)
- Type error objects properly

---

## React-Specific Rules

### Hooks Best Practices

- Only call hooks at the top level (not in loops, conditions, nested functions)
- Use exhaustive-deps rule for useEffect dependencies
- Clean up side effects in useEffect return function
- Use useRef for values that don't trigger re-renders

```tsx
// ‚úÖ GOOD
useEffect(() => {
	const timer = setInterval(() => {
		// Do something
	}, 1000)

	return () => {
		clearInterval(timer)
	}
}, [dependencies])

// ‚ùå BAD - Missing cleanup
useEffect(() => {
	setInterval(() => {
		// Do something
	}, 1000)
}, [])
```

### Context API

- Create contexts for shared state
- Use custom hooks to consume context (cleaner API)
- Split contexts by concern (don't create one giant context)

```tsx
// ‚úÖ GOOD
const FooterVisibilityContext = createContext<FooterVisibilityContextType | undefined>(undefined)

export const useFooterVisibility = () => {
	const context = useContext(FooterVisibilityContext)
	if (!context) {
		throw new Error('useFooterVisibility must be used within FooterVisibilityProvider')
	}
	return context
}
```

### Component Props

- Always define props with TypeScript interfaces
- Use default parameters for optional props
- Destructure props in function parameters
- Don't pass unnecessary props down

---

## Firebase Integration Rules

- All Firebase logic in `src/js/firebase-setup.ts`
- Export functions, not direct references
- Always handle errors with try-catch
- Use Firestore increment operations for counters
- Track statistics with proper error handling
- Type Firebase responses appropriately

---

## Performance Rules

### Code Splitting

- Use `React.lazy()` for route components
- Wrap lazy components in `Suspense`
- Use dynamic imports for heavy libraries

```tsx
// ‚úÖ GOOD
const Game = React.lazy(() => import('./components/game/Game'))

function App() {
	return (
		<Suspense fallback={<LoadingScreen />}>
			<Routes>
				<Route path="/game" element={<Game />} />
			</Routes>
		</Suspense>
	)
}
```

### Asset Optimization

- Images in `public/assets/`
- Use appropriate formats (GIF for animations, PNG for pixel art)
- Lazy load images when possible
- Use Vite's asset handling for processed assets

### Build Optimization

- Terser minification with console/debugger removal
- Tree-shaking enabled (automatic)
- Dead code elimination
- Code splitting configured in Vite

---

## Git & Deployment Rules

- **NEVER commit automatically**
- **NEVER push automatically**
- Always explain what changes were made
- Deployment via `npm run deploy` (builds and pushes to gh-pages)
- Post-build script copies `index.html` to `404.html` for SPA routing

---

## Questions You Must Ask

Before implementing anything, ask if unclear:

- "Should this be a component or a custom hook?"
- "What's the expected behavior if [edge case]?"
- "Should this be tracked in Firebase?"
- "Should this be in a Context or passed as props?"
- "Is this styling pattern repeated enough to extract to `@layer components`?"

---

## Code Review Checklist

Before suggesting code, ensure:

- ‚úÖ No duplicate code
- ‚úÖ Descriptive variable names
- ‚úÖ Proper error handling
- ‚úÖ ESLint/Prettier compliant
- ‚úÖ Follows project structure
- ‚úÖ Uses Tailwind CSS appropriately
- ‚úÖ TypeScript types defined (no `any`)
- ‚úÖ React hooks used correctly
- ‚úÖ No unused imports/variables
- ‚úÖ Comments explain "why", not "what"
- ‚úÖ Maximum 100 characters per line
- ‚úÖ Proper cleanup in useEffect

---

## Examples of Good vs Bad

### ‚ùå BAD

```tsx
const Component = (props: any) => {
	const [x, setX] = useState(0)
	const y = x * 2

	function f() {
		setX(x + 1)
	}

	return <div onClick={f}>{y}</div>
}
```

### ‚úÖ GOOD

```tsx
interface ComponentProps {
	initialValue?: number
	onValueChange?: (value: number) => void
}

export const Component: React.FC<ComponentProps> = ({
	initialValue = 0,
	onValueChange
}) => {
	const [count, setCount] = useState<number>(initialValue)
	const doubleCount = useMemo(() => count * 2, [count])

	const handleIncrement = useCallback(() => {
		const newValue = count + 1
		setCount(newValue)
		onValueChange?.(newValue)
	}, [count, onValueChange])

	return (
		<div onClick={handleIncrement} className="p-4 bg-black rounded-lg">
			{doubleCount}
		</div>
	)
}
```

### ‚ùå BAD

```tsx
<div style={{ color: 'red', padding: '10px' }}>Text</div>
```

### ‚úÖ GOOD

```tsx
<div className="text-red-500 p-4">Text</div>
```

---

## Final Reminders

- **Explain before coding**
- **Ask if unclear**
- **Never guess**
- **Always validate assumptions**
- **Keep code DRY and clean**
- **Respect the retro aesthetic**
- **Use TypeScript strictly (no `any`)**
- **Follow React hooks rules**
- **Use Tailwind utilities first, extract patterns when repeated**
- **Format and lint automatically on save**
